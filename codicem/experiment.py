import numpy as np
from typing import List, Tuple
from copy import copy, deepcopy
import matplotlib.pyplot as plt

from codicem.timings_type import *
from codicem.util import *


# These lookup tables map the string representation of a symbol type to an integer and vice versa
# useful for machine learning conversions
label_lookup_marks = {stype: i for i, stype in enumerate(marks_stypes)}
stype_lookup_marks = {i: stype for i, stype in enumerate(marks_stypes)}
label_lookup_spaces = {stype: i for i, stype in enumerate(spaces_stypes)}
stype_lookup_spaces = {i: stype for i, stype in enumerate(spaces_stypes)}


def prep_data_for_ml(timings_set, is_on):
    """Prepare the data for machine learning.  This function converts
    a dataset of timings into a format suitable for machine learning.
    It returns:
    X - a numpy column matrix of durations for marks (is_on = True) or spaces (is_on = False)
    labels - a list of stype labels for the timings - this is a list of integers from the
        stype lookup table above.
    labels_word_spaces - a list of 0 or 1 for each timing, indicating if it is a word space.
        WORD_SPACE is only about 2.5% of the training dataset so it is useful to have a separate
        criteria for classifying this.
    """
    label_lookup = label_lookup_marks if is_on else label_lookup_spaces
    timings = [t for timings in timings_set for t in timings if t.is_on == is_on]
    durations = [t.duration for t in timings]
    labels = [label_lookup[t.stype] for t in timings]
    if not is_on:
        labels_word_spaces = [int(t.stype == WORD_SPACE) for t in timings]
    else:
        labels_word_spaces = None
    X = np.array(durations).reshape(-1, 1)
    return X, labels, labels_word_spaces


def predicted2timings(timing_set: List[List[Timing]],
                      predicted_marks: np.ndarray,
                      predicted_spaces: np.ndarray
                      ) -> List[List[Timing]]:
    """Convert separate predictions for marks and spaces back into a timings set.
    timing_set is the original dataset for the prediction numpy arrays.
    predicted_marks is the predicted marks from the machine learning model.
        This is a numpy array of integers from 0 to 3.
    predicted_spaces is the predicted spaces from the machine learning model
    """
    m = predicted_marks.tolist()
    s = predicted_spaces.tolist()
    out_set = []
    for timings in timing_set:
        labeled_timings = []
        assert len(m) and len(s)
        for t in timings:
            if t.is_on:
                stype = stype_lookup_marks[m.pop(0)]
            else:
                stype = stype_lookup_spaces[s.pop(0)]
            timing_copy = deepcopy(t)
            timing_copy.stype = stype
            timing_copy.label = '~'
            labeled_timings.append(timing_copy)
        out_set.append(labeled_timings)
    return out_set


def score_timing_sets(reference: List[List[Timing]], predicted: List[List[Timing]]) -> List[int]:
    if len(reference) != len(predicted):
        raise ValueError("len(reference) != len(predicted)")
    correct = []
    for ref, pred in zip(reference, predicted):
        if ref[-1].label == pred[-1].label:
            correct.append(1)
        else:
            print(f"{timings2dashdots(ref)[0]} vs {timings2dashdots(pred)[0]}")
            correct.append(0)
    return correct


def plot_durations(durations: dict, stypes: List[int] = all_stypes) -> None:
    """Plot a histogram of the durations for each symbol type.
    durations are usually generated by the function separate_durations_by_stype()
    in timings_type.py
    """
    for sym, dt in durations.items():
        if sym in stypes:
            plt.hist(dt, bins=30, alpha=0.5, label=sym if sym != '_' else 'WORD_SPACE')
    # Add labels and legend
    plt.xlabel('Value')
    plt.ylabel('Frequency')
    plt.title('Symbol Length')
    plt.legend()
    plt.show()
